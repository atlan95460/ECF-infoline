# ═══════════════════════════════════════════════════════════════════
# APPLICATION.PROPERTIES - InfoLine API
# ═══════════════════════════════════════════════════════════════════
# Configuration Spring Boot pour l'API InfoLine
# Ces valeurs peuvent être surchargées par des variables d'environnement
# ═══════════════════════════════════════════════════════════════════

# ── APPLICATION ──────────────────────────────────────────────────────
spring.application.name=infoline-api
app.version=1.0.0
app.environment=${ENVIRONMENT:dev}

# ── SERVEUR ──────────────────────────────────────────────────────────
server.port=8080
server.servlet.context-path=/

# Compression des réponses (optimisation)
server.compression.enabled=true
server.compression.mime-types=text/html,text/xml,text/plain,text/css,text/javascript,application/javascript,application/json

# ── LOGS ─────────────────────────────────────────────────────────────
# Niveau de log par défaut
logging.level.root=INFO
logging.level.com.infoline=DEBUG

# Format des logs (JSON pour CloudWatch)
logging.pattern.console=%d{yyyy-MM-dd HH:mm:ss} - %msg%n

# ── ACTUATOR (Health & Metrics) ──────────────────────────────────────
# Activer les endpoints de monitoring
management.endpoints.web.exposure.include=health,info,metrics,prometheus
management.endpoint.health.show-details=always
management.health.livenessState.enabled=true
management.health.readinessState.enabled=true

# ── BASE DE DONNÉES (RDS PostgreSQL) ─────────────────────────────────
# Ces valeurs seront surchargées par les variables d'environnement K8s
# Exemple dans le deployment :
#   - name: DB_HOST
#     valueFrom:
#       secretKeyRef:
#         name: infoline-db-credentials
#         key: host

# Configuration JDBC
spring.datasource.url=jdbc:postgresql://${DB_HOST:localhost}:${DB_PORT:5432}/${DB_NAME:infoline}
spring.datasource.username=${DB_USERNAME:admin_infoline}
spring.datasource.password=${DB_PASSWORD:changeme}
spring.datasource.driver-class-name=org.postgresql.Driver

# JPA / Hibernate
spring.jpa.database-platform=org.hibernate.dialect.PostgreSQLDialect
spring.jpa.hibernate.ddl-auto=${DDL_AUTO:update}
spring.jpa.show-sql=${SHOW_SQL:false}
spring.jpa.properties.hibernate.format_sql=true
spring.jpa.properties.hibernate.jdbc.lob.non_contextual_creation=true

# Connection Pool HikariCP (optimisé pour Kubernetes)
spring.datasource.hikari.maximum-pool-size=10
spring.datasource.hikari.minimum-idle=5
spring.datasource.hikari.connection-timeout=30000
spring.datasource.hikari.idle-timeout=600000
spring.datasource.hikari.max-lifetime=1800000

# ── JACKSON (JSON) ───────────────────────────────────────────────────
# Configuration du serializer JSON
spring.jackson.serialization.indent-output=true
spring.jackson.serialization.write-dates-as-timestamps=false
spring.jackson.time-zone=Europe/Paris

# ── CORS (Cross-Origin Resource Sharing) ────────────────────────────
# Autoriser les requêtes depuis le frontend Angular
# ⚠️ En production, restreindre aux domaines autorisés
spring.web.cors.allowed-origins=*
spring.web.cors.allowed-methods=GET,POST,PUT,DELETE,OPTIONS
spring.web.cors.allowed-headers=*
spring.web.cors.allow-credentials=true

# ── CACHE ────────────────────────────────────────────────────────────
# Désactivé par défaut (peut être activé avec Redis)
spring.cache.type=none

# ── MULTIPART (Upload de fichiers) ──────────────────────────────────
spring.servlet.multipart.enabled=true
spring.servlet.multipart.max-file-size=10MB
spring.servlet.multipart.max-request-size=10MB

# ── PROFILS ──────────────────────────────────────────────────────────
# Profil actif (dev, test, prod)
spring.profiles.active=${SPRING_PROFILE:dev}

# ═══════════════════════════════════════════════════════════════════
# CONFIGURATION PAR ENVIRONNEMENT
# ═══════════════════════════════════════════════════════════════════
# Pour utiliser ces profils, créez des fichiers :
#   - application-dev.properties
#   - application-prod.properties
# ═══════════════════════════════════════════════════════════════════
